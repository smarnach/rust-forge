<!DOCTYPE html>
<!-- Page last generated 2019-06-11 20:38:29 +0000 -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>The Rust Release Channel Layout</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Rust, Rust programming language, rustlang, rust-lang, Mozilla Rust">
    <meta name="description" content="A systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.">
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/forge.css">
    <link rel="stylesheet" href="/rust-forge/css/bootstrap.css">
    <link rel="stylesheet" href="/rust-forge/css/style.css">
    <link rel="stylesheet" href="/rust-forge/css/forge.css">
  </head>

  <body class="container">

    <header>

    <ul class="row menu">
      <li class="col-xs-12 col-md-2">
        <a href="index.html">
	  <!-- FIXME: absolute urls -->
          <img class="img-responsive" src="https://www.rust-lang.org/logos/rust-logo-blk.svg" onerror="this.src='https://www.rust-lang.org/logos/rust-logo-256x256-blk.png'" height="128" width="128" alt="Rust logo" />
        </a>
      </li>
      <li class="col-xs-12 col-md-6 menu">
	<h1>Rust Forge</h1>
      </li>
    </ul>
    </header>

    <div class="content"><p><strong>NOTE</strong> This document should be considered incomplete and descriptive rather
than normative. Do not rely on anything described herein to be fully correct
or a definition of how things <em>should</em> be done.</p>

<p>A lot of the content herein is derived from <a href="https://internals.rust-lang.org/t/future-updates-to-the-rustup-distribution-format/4196#the-static-rust-lang-org-layout">a posting made to the Rust internals
forum by Brian Anderson back in 2016</a>.</p>

<h1 id="the-rust-release-channel-layout">The Rust Release Channel Layout</h1>

<p>Rust releases are deployed onto <code class="highlighter-rouge">static.rust-lang.org</code> where they are served
via <code class="highlighter-rouge">https</code>. There are several parts to a release channel (<code class="highlighter-rouge">stable</code>, <code class="highlighter-rouge">beta</code>,
<code class="highlighter-rouge">nightly</code>) but they all key off a manifest file and then go from there.</p>

<h2 id="channel-manifests">Channel manifests</h2>

<p>There is a top level directory <code class="highlighter-rouge">/dist/</code> which contains the channel manifests. The
manifests are named <code class="highlighter-rouge">channel-rust-[channelname].toml</code>. Each channel manifest
is accompanied by a <code class="highlighter-rouge">.sha256</code> file which is a checksum of the manifest file and
can be used to check integrity of the downloaded data. In addition each channel’s
manifest is also accompanied by a <code class="highlighter-rouge">.asc</code> file which is a detached GPG signature
which can be used to check not only the integrity but also the authenticity of
the channel manifest.</p>

<p>In addition to the <code class="highlighter-rouge">stable</code>, <code class="highlighter-rouge">beta</code>, and <code class="highlighter-rouge">nightly</code> channels, there is also a manifest
for each release which will be called <code class="highlighter-rouge">channel-rust-x.yy.z.toml</code> with its
associated <code class="highlighter-rouge">.sha256</code> and <code class="highlighter-rouge">.asc</code> files.</p>

<p>To support date-based channels, there is an archive folder for each day (labelled
<code class="highlighter-rouge">YYYY-MM-DD</code>) which contains copies of the requisite channel files on that day.
So, for example, if you installed <code class="highlighter-rouge">nightly-2019-02-16</code> then the channel file
would be <a href="https://static.rust-lang.org/dist/2019-02-16/channel-rust-nightly.toml">https://static.rust-lang.org/dist/2019-02-16/channel-rust-nightly.toml</a>.</p>

<h3 id="content-of-channel-manifests">Content of channel manifests</h3>

<p>Channel manifests are <code class="highlighter-rouge">toml</code> files. These are known as <em>v2</em> manifests. The <em>v1</em>
manifests are simply lists of the files associated with a release and are not
generated for every channel all of the time. Currently it is recommended to
work only with the <em>v2</em> manifests and these are the topic of this section.</p>

<p>The top level of the <code class="highlighter-rouge">.toml</code> file consists of two important key/value pairs.
Firstly the <code class="highlighter-rouge">manifest-version</code> which is, at this time, <code class="highlighter-rouge">"2"</code>, and secondly
the date of the manifest (<code class="highlighter-rouge">date</code>) whose value is of the form <code class="highlighter-rouge">"YYYY-MM-DD"</code>.</p>

<p>There are then a number of top level sections (tables) which are:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">pkg</code> - This contains the bulk of the manifest and lists the packages which
are part of the release. Typically this will be things like <code class="highlighter-rouge">rust</code>, <code class="highlighter-rouge">rustc</code>,
<code class="highlighter-rouge">cargo</code> etc. The <code class="highlighter-rouge">rust</code> package is semi-special and currently is used to
specify the subset of other packages which will be installed by default.</p>

    <p>Within packages are <code class="highlighter-rouge">components</code> and <code class="highlighter-rouge">extensions</code>. Currently <code class="highlighter-rouge">components</code> are
installed by default by <code class="highlighter-rouge">rustup</code>, <code class="highlighter-rouge">extensions</code> are optional components and
are available via <code class="highlighter-rouge">rustup component add</code> and friends.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">renames</code> - This contains a set of package renames which can be used to determine
the correct package to fetch when the user enters an alias for it.</p>

    <p>Typically renames are used when a package leaves its preview state and is considered
to be release quality. For example, the actual package for <code class="highlighter-rouge">rustfmt</code> is called
<code class="highlighter-rouge">rustfmt-preview</code> but since its release there has been a <code class="highlighter-rouge">renames.rustfmt</code>
table whose <code class="highlighter-rouge">to</code> field is <code class="highlighter-rouge">rustfmt</code>. When the user runs <code class="highlighter-rouge">rustup component add rustfmt</code>
the name is automatically translated to <code class="highlighter-rouge">rustfmt-preview</code> and when the user
runs <code class="highlighter-rouge">rustup component list</code> then <code class="highlighter-rouge">rustfmt-preview</code> is automatically renamed
back to <code class="highlighter-rouge">rustfmt</code> for display to the user.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">profiles</code> - This is part of the future setup for deciding the default component
set to install. Instead of choosing the <code class="highlighter-rouge">components</code> of <code class="highlighter-rouge">pkg.rust</code> instead
<code class="highlighter-rouge">rustup</code> will honour one of the entries in the <code class="highlighter-rouge">profiles</code> table. Usually this
will be the <code class="highlighter-rouge">default</code> entry which <em>essentially</em> (though not exactly) boils down
to <code class="highlighter-rouge">["rustc", "cargo", "rust-std", "rust-docs", "rustfmt", "clippy"]</code>.</p>

    <p>Other profiles include <code class="highlighter-rouge">minimal</code> (<code class="highlighter-rouge">["rustc", "cargo", "rust-std"]</code>) and
<code class="highlighter-rouge">complete</code> which adds in additional tools such as the <code class="highlighter-rouge">rls</code>, a copy of
the standard library source (<code class="highlighter-rouge">rust-src</code>), <code class="highlighter-rouge">miri</code>, <code class="highlighter-rouge">lldb</code>, <code class="highlighter-rouge">llvm-tools</code>, and
<code class="highlighter-rouge">rust-analysis</code>.</p>
  </li>
</ul>

<h3 id="package-entries-in-the-channel-manifest">Package entries in the channel manifest</h3>

<p>As stated above, packages list their components and extensions (mostly just the
<code class="highlighter-rouge">rust</code> package) and they can provide per-target tarball and sha256 data.</p>

<p>For example, a package might be:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[pkg.cargo.target.powerpc64-unknown-linux-gnu]</span>
<span class="py">available</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">url</span> <span class="p">=</span> <span class="s">"https://static.rust-lang.org/dist/2019-05-23/cargo-0.36.0-powerpc64-unknown-linux-gnu.tar.gz"</span>
<span class="py">hash</span> <span class="p">=</span> <span class="s">"279f3a84f40e3547a8532c64643f38068accb91c21f04cd16e46579c893f5a06"</span>
<span class="py">xz_url</span> <span class="p">=</span> <span class="s">"https://static.rust-lang.org/dist/2019-05-23/cargo-0.36.0-powerpc64-unknown-linux-gnu.tar.xz"</span>
<span class="py">xz_hash</span> <span class="p">=</span> <span class="s">"cf93b387508f4aea4e64f8b4887d70cc07a00906b981dc0c143e92e918682e4a"</span>
</code></pre></div></div>

<p>Here you can see that this is for the <code class="highlighter-rouge">cargo</code> package, and for the <code class="highlighter-rouge">powerpc64-unknown-linux-gnu</code> target.
The <code class="highlighter-rouge">url</code>/<code class="highlighter-rouge">hash</code> combo is for a <code class="highlighter-rouge">.tar.gz</code> and the <code class="highlighter-rouge">xz_url</code>/<code class="highlighter-rouge">xz_hash</code> pair for the same
tarball compressed with <code class="highlighter-rouge">xz</code>.
Either pair of url and hash could be present, both may be present, but it is not
useful for neither to be present unless <code class="highlighter-rouge">available</code> is set to <code class="highlighter-rouge">false</code> to indicate
that that particular combiantion of package and target is unavailable in this channel
at this time.</p>

<p>In addition, there will be a single entry providing the version for a package
in the form:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[pkg.cargo]</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.36.0 (6f3e9c367 2019-04-04)"</span>
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">version</code> will be effectively the <code class="highlighter-rouge">$tool --version</code> output, minus the tool’s name.</p>

<h2 id="targets">Targets</h2>

<p>Targets are the same triples you might use when building something with <code class="highlighter-rouge">cargo build --target=$target</code>
and you can add them to your installation using <code class="highlighter-rouge">rustup target add $target</code>.
When you do that, what <code class="highlighter-rouge">rustup</code> actually does is to find the <code class="highlighter-rouge">rust-std</code> package
for the target in question and installs that. Essentially like an imaginary
<code class="highlighter-rouge">rustup component add rust-std.$target</code>.</p>

<p>If a <code class="highlighter-rouge">rust-std</code> package for a target is not <code class="highlighter-rouge">available = true</code> then that target
cannot be installed via <code class="highlighter-rouge">rustup</code>. This can happen for lower tier targets from
time to time.</p>

<p>Since components and extensions are target-specific in the <code class="highlighter-rouge">pkg</code> tables, you
will be able to see that <code class="highlighter-rouge">rust-std</code> for every target is specified in every
<code class="highlighter-rouge">rust</code> target’s extensions. This allows for cross-compilation by installation
of any <code class="highlighter-rouge">rust-std</code> on any build system.</p>
</div>

  </body>
</html>
